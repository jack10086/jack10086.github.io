<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++定义了几种基本的内置类型，如字符、整形、浮点数等。 基本内置类型基本内置类型包括算数类型和空类型(void)，算数类型包括字符、整数型、浮点数和布尔值。 算数类型算数类型分为整数型和浮点型两类。字符和布尔值都属于整型。C++定义了各类型的最小尺寸：bool未定义，char 8位，short 16位，int 16位，long 32位，long long 64位；float是32位4字节，包括6">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer-2. 基本类型">
<meta property="og:url" content="http://yoursite.com/post/f2c4b155.html">
<meta property="og:site_name" content="诗鸩的笔记簿">
<meta property="og:description" content="C++定义了几种基本的内置类型，如字符、整形、浮点数等。 基本内置类型基本内置类型包括算数类型和空类型(void)，算数类型包括字符、整数型、浮点数和布尔值。 算数类型算数类型分为整数型和浮点型两类。字符和布尔值都属于整型。C++定义了各类型的最小尺寸：bool未定义，char 8位，short 16位，int 16位，long 32位，long long 64位；float是32位4字节，包括6">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-26T04:26:16.980Z">
<meta property="article:modified_time" content="2022-10-26T04:29:53.605Z">
<meta property="article:author" content="诗鸩">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/post/f2c4b155.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/post/f2c4b155.html","path":"post/f2c4b155.html","title":"C++ primer-2. 基本类型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ primer-2. 基本类型 | 诗鸩的笔记簿</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">诗鸩的笔记簿</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">基本内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">算数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">字面值常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">1.3.1.</span> <span class="nav-text">整型和浮点型字面值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">1.3.2.</span> <span class="nav-text">字符和字符串字面值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="nav-number">1.3.3.</span> <span class="nav-text">转义序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">指定字面值的类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">变量定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.</span> <span class="nav-text">变量的声明和定义的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text">标识符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">3.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">3.3.</span> <span class="nav-text">理解复合类型的声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">4.</span> <span class="nav-text">const限定符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">const的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="nav-number">4.2.</span> <span class="nav-text">指针和const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82const"><span class="nav-number">4.3.</span> <span class="nav-text">顶层const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">constexpr和常量表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">处理类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">5.1.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">auto类型说明符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">decltype类型指示符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">自定义数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">6.2.</span> <span class="nav-text">编写自己的头文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">问题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="诗鸩"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">诗鸩</p>
  <div class="site-description" itemprop="description">暴搜流派！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/jack_jxnu" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;jack_jxnu" rel="noopener" target="_blank">CSDN</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/post/f2c4b155.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="诗鸩">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="诗鸩的笔记簿">
      <meta itemprop="description" content="暴搜流派！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ primer-2. 基本类型 | 诗鸩的笔记簿">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ primer-2. 基本类型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-26 12:26:16 / 修改时间：12:29:53" itemprop="dateCreated datePublished" datetime="2022-10-26T12:26:16+08:00">2022-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>C++定义了几种基本的内置类型，如字符、整形、浮点数等。</p>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>基本内置类型包括算数类型和空类型(void)，算数类型包括字符、整数型、浮点数和布尔值。</p>
<h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><p>算数类型分为整数型和浮点型两类。字符和布尔值都属于整型。<br>C++定义了各类型的最小尺寸：bool未定义，char 8位，short 16位，int 16位，long 32位，long long 64位；<br>float是32位4字节，包括6位有效数字，double是64位8字节，包括10位有效数字。</p>
<p>int、short、long都是带符号类型，char由编译器决定是否有符号。<br>C++提供了几种字符类型：</p>
<ol>
<li>char：一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值，即一个char的大小和一个机器字节一样。</li>
<li>wchar_t：宽字节，用于拓展字符集，wchar_t确保可以存放机器最大扩展字符集中的任意一个字符。</li>
<li>char16_t和char32_t：为Unicode字符集服务。</li>
</ol>
<p><b>类型选择</b>：</p>
<ul>
<li>明确数值不可能为负时，选用无符号类型。</li>
<li>整数运算用int，数值太大用long long，不用short和long</li>
<li>浮点数运算用double。float和double的计算代价相差无几。</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>几种类型转换的情况：</p>
<ol>
<li>把浮点数赋给整型时，结果仅保留小数点前的部分。</li>
<li>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如-1赋给8位unsigned char，结果是255。</li>
<li>赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。</li>
</ol>
<p>程序应尽量避免依赖于实现环境的行为。比如int的尺寸在不同环境可能不同。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><h4 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h4><p><b>整型字面值中0开头的整数是8进制，0x开头的整数是16进制。</b></p>
<h4 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h4><p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。<br>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（’\0’），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。<br>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写。</p>
<h4 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h4><p>换行符：\n，横向制表符：\t,，报警符：\a，纵向制表符：\v，退格符：\b，双引号：&quot;，<br>反斜线：\，单引号：&#39;，问号：?，回车符：\r，进纸符：\f<br>在程序中，上述转义序列被当作一个字符使用。<br>也可以使用泛化的转移序列，形式是 / 后跟 1~3 个八进制数字或 \x 后跟 1 个或多个十六进制数字。</p>
<h4 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h4><p>给字面值增加前缀或后缀来改变字面值的默认类型。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>对于C++而言，“变量”和“对象”一般可以互换使用。<br>C++中，对象通常指一块能存储数据并具有某种类型的内存。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值。<br>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。定义与任何函数之外的内置类型则被默认初始化为0。<br>类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。<br>不能使用未初始化的变量，否则会引发运行时故障。<br>建议初始化每一个内置类型的变量。</p>
<h3 id="变量的声明和定义的关系"><a href="#变量的声明和定义的关系" class="headerlink" title="变量的声明和定义的关系"></a>变量的声明和定义的关系</h3><p>声明和定义是严格区分的。<br>声明使得名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对该名字的声明。而定义负责创建实体。<br>用extern声明而非定义一个变量，并且不要显式地初始化变量。<br><b>变量可以声明多次，只能定义一次。</b></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;     <span class="comment">// 声明 i 而非定义</span></span><br><span class="line"><span class="type">int</span> j;            <span class="comment">// 定义并且声明 j；</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// 定义 k，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>
<p>声明和定义的区分很重要<br><font color="red">c++是静态类型语言，其含义是在编译阶段检查类型。</font></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符由<font color="red">字母、数字和下划线</font>组成，不得以数字开头。标识符长度无限制，但对大小写敏感。<br>用户自定义的标识符不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。</p>
<p>变量命名规范：</p>
<ol>
<li>标识符要体现其实际含义；</li>
<li>变量名一般小写；</li>
<li>用户自定义的类名一般以大写字母开头；</li>
<li>如果标识符由多个单词组成，则单词间应有明显的区分。</li>
</ol>
<p>对于嵌套作用域，允许在内层作用域中重新定义外层作用域已有的名字，但最好不要！</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型就是基于其他类型定义的类型，引用和指针就是其中两种。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是给对象起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。<br>引用必须初始化。引用的初始值必须是一个对象，不能是字面值或表达式。<br>对引用的所有操作都是对与之绑定的对象的操作。<br>引用本身不是对象，故不能定义引用的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r = i;</span><br></pre></td></tr></table></figure>
<p>引用只能绑定同类型的对象。<br>严格来说，当我们使用术语“reference”时，指的是左值引用。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>在块作用域内，指针如果没有被初始化，其值将不确定。<br>指针必须指向指定类型，不能指向其他类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> *dp = &amp;i;   <span class="comment">// 错误</span></span><br><span class="line"><span class="type">long</span> *lp = &amp;i;     <span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> *ip = i;       <span class="comment">// 这个也是错误的，但 int *ip = 0; 是正确的</span></span><br></pre></td></tr></table></figure>
<p><b>指针与引用的不同：</b></p>
<ol>
<li>指针是一个对象而引用不是；</li>
<li>指针可以重定向而引用不行；</li>
<li>有指向指针的指针，无引用的引用；</li>
<li>指针不强制赋初值，而引用需要。</li>
</ol>
<p>不能定义指向引用的指针，可以定义指向指针的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; </span><br><span class="line"><span class="type">int</span>* &amp;r = p;      <span class="comment">// r是对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>对于如上 <em>&amp;r 这种比较复杂的指针或引用的声明语句时，从右往左读比较易于弄清。<br>利用解引用符（</em>）可以访问指针指向的对象。</p>
<p><b>空指针</b></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// 三种定义空指针的方式。最好用第一种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>
<p><font color="red">建议初始化所有指针</font>。<br>非零指针对应的条件是true，零指针对应的条件值是false。</p>
<p><b>void<em>指针</b><br>void指针和空指针不是一回事。<br><font color="red">void</em>指针是特殊的指针类型，可以存放任意对象的地址。</font>它的用处比较局限。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>定义复合类型的变量要比基本类型的变量复杂很多。<br>一条声明语句是由一个基本数据类型和紧随其后的声明符列表组成的。<br>引用符&amp; 和 指针符* 都是类型说明符，类型说明符是声明的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a=b, &amp;c=b;</span><br><span class="line"><span class="type">int</span> *a=<span class="literal">nullptr</span>, b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象必须初始化，因为它一旦创建不允许改变。<br>默认情况下，const对象仅在文件内有效。<br>如果想在多个文件内共享const对象，必须在变量的定义前添加 <strong>extern</strong> 关键字，并在本文件中声明。声明和定义都要加extern。</p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。<br>引用必须初始化，所以常量引用也必须初始化。<br>注意引用不是对象，因此常量引用不是说引用是常量，而是说引用不能改变绑定的对象。<br>引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;  <span class="comment">// 用于声明引用的 const 都是底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p = <span class="number">42</span>;  <span class="comment">// 常量引用可以绑定字面值</span></span><br></pre></td></tr></table></figure>
<p>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>指向常量的指针用法和常量引用非常相似，但并不一样。它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其它方式改变值。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>顶层const表示指针本身是个常量，底层cocnst表示指针所指的对象是个常量。<br>更广泛地来说：顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，比如算数类型、类、指针等。底层const则与指针和引用等符合类型的基本类型部分有关。</p>
<p>顶层const的指针表示该指针是const对象，因此必须初始化。底层const指针则不用。<br>实际上只有指针类型既可以是顶层const也就可以是底层const，因为引用只能是底层const，常量引用即为底层const，不存在顶层const的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> p2 = p1;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>从右往左读来判断是顶层const还是底层const。<br>对于指针和引用而言，顶层const在右边，底层const在左边。对于其它类型，全都是顶层const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;c;       <span class="comment">// 这是一个底层const，允许改变 p2 的值</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p1 = &amp;i;       <span class="comment">// 这是一个顶层const，不能改变 p1 的值</span></span><br></pre></td></tr></table></figure>
<p>执行拷贝操作时，不能将底层const拷贝给非常量。</p>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p>常量表达式是指值不会改变，且在编译过程中就能得到计算结果的表达式。<br>字面值属于常量表达式，由常量表达式初始化的const对象也是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">32</span>;          <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a + <span class="number">1</span>;       <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>;                 <span class="comment">// 不是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// 不是常量表达式，因为虽然 sz 是常量，但它的具体值等到运行时才知道。</span></span><br></pre></td></tr></table></figure>

<p><b>constexpr变量</b><br>在实际应用中很难分辨一个初始量是否常量表达式，通过将变量声明为constexpr类型即可由编译器来检查。<br>声明为constexpr的变量一定是一个常量，且必须用常量表达式初始化。<br>建议：如果认定一个变量是常量表达式，那就把它声明为constexpr类型。<br>允许定义constexpr函数，这种函数应该足够简单，以使得编译时就可以计算其结果。<br>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">//只有当 size() 是一个 constexpr 函数时这才是一条正确的声明语句。</span></span><br></pre></td></tr></table></figure>

<p><b>字面值类型</b><br>算数类型、引用、指针都属于字面值类型。自定义类则不属于。<br>constexpr指针的初始值必须是nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。<font color="red">函数体之外的对象和静态变量的地址都是固定不变的</font></p>
<p><b>指针和constexpr</b><br>注意区分constexpr和const。constexpr是顶层const，仅对指针本身有效。<br>constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。<br>const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。<br>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</p>
<h2 id="处理类别"><a href="#处理类别" class="headerlink" title="处理类别"></a>处理类别</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>有两种方法定义类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages, *p;  <span class="comment">// 使用 typedef 关键字，wages是double的同义词，p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>;  <span class="comment">// 使用 using 关键字进行别名声明</span></span><br></pre></td></tr></table></figure>
<p>typedef 作为声明语句中的基本数据类型的一部分出现。含有 typedef 的声明语句定义的不再是变量而是类型别名。和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造复合类型。</p>
<p><b>指针、常量和类型别名</b><br>直接替换的理解方式是错误的。声明语句中用到pstring时，其基本类型是指针。<br>可是用 char* 替换后，char 成了数据类型，*成为了声明符的一部分。<br>替换前声明了一个指向char的常量指针，替换后声明了一个指向const char的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pstring; </span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 注意：const 是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr = 0，这是错误的。</span></span><br></pre></td></tr></table></figure>

<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto说明符让编译器根据初始值来分析表达式所属的类型。理解：<font color="red">auto会增加编译时间，但不会增加运行时间。</font><br>auto可以在一条语句中声明多个变量，但它们必须是同一基本数据类型。</p>
<p><b>复合类型、常量和auto</b><br>编译器推断出的auto类型有时和初始值并不一样，编译器会进行适当调整：</p>
<ol>
<li>auto 根据引用来推断类型时，会以引用对象的类型作为 auto 的类型。</li>
<li>auto 一般会忽略掉顶层const。如果希望auto是一个顶层const，需要明确指出。</li>
<li>auto会保留底层const。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;       <span class="comment">// b 是一个普通的 int。</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;       <span class="comment">// c 是一个普通的 int。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;e = ci;      <span class="comment">// e 是一个常量引用（常量引用是底层 const）。注意这个微妙的地方。</span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci;      <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure>

<p>int 与 int *、int &amp; 是一个基本数据类型，而 const int 与 int 不是一种类型。<br>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>当希望获得表达式的类型但不需要值时，可以使用类型说明符decltype。<br>如果 decltype 使用的表达式是一个变量，它将返回该变量的类型（包括顶层const和引用）。<br>注意当获得的类型是引用时，必须初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;  <span class="comment">// x 的类型是 const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;  <span class="comment">// y 的类型是 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">// z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p><font color="green">引用从来都是作为对象的别名出现，只有在 decltype 处是例外。</font></p>
<p><b>decltype和引用</b><br>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。<br>注意解引用指针的结果是一个引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, &amp;r = i, *p;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;      <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i;   <span class="comment">// c 的类型是 int&amp;。</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = i;  <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>struct+类名+类体+分号，类体可以为空。<br>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。<br>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>
<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>类通常定义在头文件中，类所在的头文件名字应与类的名字一样。<br>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr等。<br>头文件一旦改变，相关原文件必须重新编译以获得更新过的声明。</p>
<p><b>预处理器概述</b><br>确保头文件多次包含仍能正常工作的常用技术是<font color="red">预处理器</font>.<br>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。<br>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>
<p>头文件保护符：</p>
<ol>
<li>#define：把一个名字设定为预处理变量</li>
<li>#ifdef：当且仅当变量已定义时为真</li>
<li>#ifndef：当且仅当变量未定义时为真</li>
<li>#endif：一旦2，3的检查结果为真，则执行后续操作直到遇到 #endif 为止</li>
</ol>
<p>预处理变量无视作用域的规则，作用范围是文件内</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>说出指针和引用的四点不同？<ul>
<li>指针是对象而引用不是；</li>
<li>指针可以重定向而引用不行；</li>
<li>有指向指针的指针，无引用的引用；</li>
<li>引用必须初始化，指针非必须。</li>
</ul>
</li>
<li>const对象必须？<ul>
<li>初始化。</li>
</ul>
</li>
<li>const对象的作用范围？<ul>
<li>默认是文件内。</li>
</ul>
</li>
<li>什么是常量引用，如何声明，是顶层还是底层？<ul>
<li>不能改变对象的引用是常量引用，const int&amp; a=b，是底层const。</li>
</ul>
</li>
<li>常量引用与常量对象、非常量对象的关系：<ul>
<li>不能用非常量引用绑定常量对象，可以用常量引用绑定非常量对象。</li>
</ul>
</li>
<li>什么是常量指针，如何声明，是顶层还是底层？<ul>
<li>常量指针表明指针是个常量，其存储的地址不能变，但指针还能修改所指对象的值。int* const p = a，是顶层const。</li>
</ul>
</li>
<li>常量指针与常量对象、非常量对象的关系：<ul>
<li>可以用常量指针只想非常量对象。</li>
</ul>
</li>
<li>顶层 const 和底层 const 都是什么，在什么位置？<ul>
<li>顶层const表示指针本身是常量，底层const表示所指对象是常量。顶层 const 在右边，底层 const 在左边。</li>
</ul>
</li>
<li>如何区分顶层 const 和底层 const？<ul>
<li>只有指针同时有顶层和底层，const在星号右边是顶层，左边是底层。引用的 const 是底层，其他类型 const 是顶层。</li>
</ul>
</li>
<li>constexpr 是什么，特点是什么？<ul>
<li>常量表达式。值不能改变、在编译阶段计算。</li>
</ul>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/d9f45d1f.html" rel="prev" title="单调队列">
                  <i class="fa fa-chevron-left"></i> 单调队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/e1553121.html" rel="next" title="KMP模式匹配算法">
                  KMP模式匹配算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">诗鸩</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
